#!/usr/bin/perl -w
#
# Copyright © 2013 Marc-André Pelletier <mpelletier@wikimedia.org>
#
# Permission to use, copy, modify, and/or distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
#

use strict;
use warnings;
use English;

use IPC::Run qw(harness run);
use String::ShellQuote;

# Log this command invocation to EventLogging
my $full_commandline = join " ", $0, @ARGV;
system('/usr/local/bin/log-command-invocation', 'jsub', $full_commandline) unless (exists ($ENV {'JOBUTILS_QSUB'}));

# Supported qsub options and whether they take an argument or not
my %qsubargs = (
       '-a' => 1, '-b' => 1, '-cwd' => 0, '-e' => 1, '-hard' => 0, '-i' => 1, '-j' => 1,
       '-l' => 1, '-now' => 1, '-N' => 1, '-o' => 1, '-p' => 1, '-q' => 1, '-soft' => 0,
       '-sync' => 1, '-v' => 1, '-wd' => 1, '-M' => 1, '-m' => 1,
       '-mem' => 1, '-once' => 0, '-stderr' => 0, '-continuous' => 0, '-quiet' => 0,
       '-umask' => 1,
);
my %qsargs;
my @args;
my $memory = memparse_kb('512M');
my $once = 0;
my $stderr = 0;
my $continuous = 0;
my $quiet = 0;
my $script = $0;
my $queue = 'task';
my $username = $ENV{LOGNAME} || $ENV{USER} || getpwuid($<);
my $mailto = "$username\@tools.wmflabs.org";

# Set $script to the filename of the current process
# (e.g. "jsub", "jstart", "qcronsub", ...)
$script = $1 if $script =~ m{/([^/]+)$};

sub memparse_kb {
  # parses an XXK, XXm, XXg to the # of kilobytes
  my $arg = $_[0];
  if ($arg !~ m/^([1-9][0-9]*)([mgk])$/i) {
    die "$script: memory value must be an integer followed by 'k', 'm' or 'g': $_[0]\n";
  }

  my $amount = $1;
  my $unit = $2;
  if($unit =~ m/[mg]/i) {$amount *= 1024};
  if($unit =~ m/[g]/i) {$amount *= 1024};

  return $amount;
}

# Set default umask for output files depending on whether we're called
# by a user or a tool.
my $umask = $EFFECTIVE_USER_ID >= 50000 ? oct ('007') : oct ('077');

# If called as `jstart` set the $continuous and $once flags
$continuous = $once = 1 if ($script eq 'jstart');
# If called as `qcronsub` set the $once flag
$once = 1 if $script eq 'qcronsub';

my @options;
# Look for $JOBUTILS_JSUBRC or ~/.jsubrc options file with additional options
my $jsubrcfilename = exists ($ENV {'JOBUTILS_JSUBRC'}) ? $ENV {'JOBUTILS_JSUBRC'} : (getpwuid ($REAL_USER_ID)) [7] . '/.jsubrc';
if(open (my $rc, '<', $jsubrcfilename)) {
  while(<$rc>) {
    if(m/^(-[a-z]+)(?:\s+(.+)|\s*)$/) {
      my($opt, $optarg) = ($1, $2);
      die "$0: unknown option '$1' in .jsubrc\n"  unless defined $qsubargs{$opt};
      die "$0: option '$1' in .jsubrc needs an argument\n"  if $qsubargs{$opt} and not defined $optarg;
      push @options, [ $opt, $optarg ];
    }
  }
  close ($rc);
}

# Scan command line arguments
while($#ARGV > 0) {
  # Stop when you hit an argument that isn't in the expected list
  last unless defined $qsubargs{$ARGV[0]};
  my $opt = shift;
  my $optarg = undef;
  if($qsubargs{$opt}) {
    die "$script: option $opt requires an argument\n" unless $#ARGV > 0;
    $optarg = shift;
  }
  push @options, [ $opt, $optarg ];
}


if($#ARGV<0 or $ARGV[0] =~ m/^-/) {
  # Ran out of arugments without a program to exec or have an unknown option
  print STDERR <<"END"

usage: $script [options...] program [arg...]

Options include many (but not all) qsub options, along with:
 -stderr           Send errors to stderr rather than the error
                   output file.
 -mem <value>      Request <value> amount of memory for the job.
                   (number prefixed by 'k', 'm' or 'g')
 -once             Only start one job with that name, fail if
                   another is already started or queued (default
                   if invoked as 'jstart' or 'qcronsub').
 -continuous       Start a self-restarting job on the continuous
                   queue (default if invoked as 'jstart')
 -umask <value>    Set umask for output files if they don't exist
 -quiet            If successful, don't output anything

Unlike qsub, if you do not specify output and error files, output is appended
by default to files named <job>.err and <job>.out in your home directory
(without job numbers), including errors from starting the job itself.

Additionally, you need to provide an executable on the command line,
$script will not read a script from standard input.

END
  ;
  exit 1;
}

# Next argument is the program to run
my $exe = shift;
# Resolve program relative to $PATH
my $prog = `/usr/bin/which $exe`;
chomp $prog;
# Resolve all symlinks
while(-l $prog) {
  my $symlink = readlink $prog;
  if($symlink =~ m{^/}) {
    $prog = $symlink;
    next;
  }
  $prog =~ s{/[^/]+$}{};
  while($symlink =~ m{^\.\./(.*)}) {
    $symlink = $1;
    $prog =~ s{/[^/]+$}{};
  }
  $prog .= "/$symlink";
}

# Check to see if we have an absolute path yet
unless($prog =~ m{^/}) {
  # Nope. Then it must be relative to the current working directory
  my $cwd = `pwd`;
  chomp $cwd;
  $prog = "$cwd/$exe";
  # Collapse '/./' to '/'
  $prog =~ s{/\./}{/}g;
}

# Scan the program looking for more option directives embedded in the script
# as '#$ -SOMETHING' comments. This mostly matches the behavior of SGE's qsub.
# See '-C prefix_string' in `man qsub` for more ugly details.
open EXE, "<$prog" or die "$prog: $!\n";
my $shebang;
while(read EXE, $shebang, 2) {        # Read the next 2 characters
  last unless $shebang =~ m/^#[!\$]/; # Stop unless we read '#!' or '#$'
  my $rest =<EXE>;                    # Read through the next newline
  next if $shebang eq '#!';
  # Capture options from $rest if present
  # Arguments look like '-FLAG' or '-OPT ARG'
  next unless $rest =~ m/\s* ( -\S+ ) (?: \s+ ( [^# \n\t]+ ) )?/x;
  # Add captured values to our growing collection of options
  unshift @options, [ $1, $2 ];
}
close EXE;

# Evaluate the options that we have captured from the rc file, command line,
# and the script itself.
foreach my $option (@options) {
  my($opt, $optval) = @$option;
  if($opt eq '-mem') {
    $memory = memparse_kb($optval);
  } elsif($opt eq '-once') {
    $once = 1;
  } elsif($opt eq '-stderr') {
    $stderr = 1;
  } elsif($opt eq '-continuous') {
    $continuous = 1;
    $once = 1;
  } elsif($opt eq '-umask') {
    die ("$script: umask must be an octal value: $optval\n")
      unless ($optval =~ /^[0-7]+$/);
    $umask = oct ($optval);
  } elsif($opt eq '-quiet') {
    $quiet = 1;
  } else {
    if($opt eq '-l') {
      # Process qsub's insane '-l resource=value,...' options
      # If there is an 'h_vmem=...' option, remove it and set $memory
      $memory = memparse_kb($1) if $optval =~ s/h_vmem=([0-9]+[mMgGkK]),?//;
      # If there is a 'virtual_free=...' option, remove it and ...
      if ($optval =~ s/virtual_free=([0-9]+[mMgGkK]),?//) {
        my $vfmem = memparse_kb($1);
        if ($vfmem > $memory) {
            # If config asks for more virtual_free than h_vmem,
            # warn the caller and bump h_vmem.
            my $new_mem = $vfmem * 1.1;
            print "WARNING: virtual_free=${vfmem}k is larger than h_vmem=${memory}k. Setting h_vmem=${new_mem}k\n";
            $memory = $new_mem;
        }
      }
      # Continue to next option if we have chopped out all of the values in
      # this one (skips adding to $qsargs below).
      next if $optval =~ m/^,?$/;
    }
    # Add parsed option to $qsargs map
    $qsargs{$opt} = $optval;

    # Continue to next option if we saw '-N NAME', '-q QUEUE', or '-b y|n'
    next if $opt eq '-N' or $opt eq '-q' or $opt eq '-b';

    # Add option and value to argument stack
    push @args, $opt;
    push @args, $optval if defined $optval;
  }
}

# Take the program filename minus any extension as the job name
# (e.g. '/home/foo/fobar.sh' -> 'foobar')
my $jobname = $1 if $prog =~ m{([^/.]+)(\.[^/]*)?$};
# If we found a '-N NAME' option earlier, use that name instead
$jobname = $qsargs{'-N'} if defined $qsargs{'-N'};

# Decide on filenames for stderr and stdout
# Defaults are: $HOME/$jobname.(err|out)
my $err = (getpwuid ($REAL_USER_ID)) [7] . '/' . $jobname . '.err';
my $out = (getpwuid ($REAL_USER_ID)) [7] . '/' . $jobname . '.out';

# If we got an '-e /path/to/stderr' option, use it
$err = $qsargs{'-e'} if defined $qsargs{'-e'};
# If we got an '-o /path/to/stdout' option, use it
$out = $qsargs{'-o'} if defined $qsargs{'-o'};
# Use the same file for stderr as stdout if we saw a '-j y' option
$err = $out if defined $qsargs{'-j'} and $qsargs{'-j'} =~ m/^[yY]/;

# For STDOUT and STDERR we do the same dance:
# - If the output file exists, we do nothing (the output file being a
#   directory is a subset of this).
# - Otherwise, we touch the output file once with the set umask.
my $oldumask = umask ($umask);
if (!-e $out) {
  open (my $tempfh, '>>', $out) or
    die ("Couldn't touch '$out': $!");
  close ($tempfh);
}
if (!-e $err) {
  open (my $tempfh, '>>', $err) or
    die ("Couldn't touch '$err': $!");
  close ($tempfh);
}
# - If -stderr is not given and the error output file is not a
#   directory, we redirect STDERR to it.
if (!$stderr && !-d $err) {
  open (STDERR, '>>', $err) or
    die ("Couldn't redirect STDERR to '$err': $!");
}
umask ($oldumask);

my $now = localtime;

die "\[$now\] $prog: not an executable file\n" unless -f $prog and -x $prog;

if($once) {
  # Check to see if this named job is live on the grid if we are only supposed
  # to run a single copy
  my $running = system "/usr/bin/job", '-q', $jobname;
  die "\[$now\] unable to get job status\n" if $running & 127;
  $running >>= 8;
  die "\[$now\] there is a job named '$jobname' already active\n" unless $running==0;
}

# Add default arguments for /usr/bin/qsub
$mailto = $qsargs{'-M'} if defined $qsargs{'-M'};
# Set stderr log file for the job unless we saw a '-e /path/to/stderr' option
# bd808: I think this is a bug as $qsargs{'-e'} is not used later
push @args, '-e', $err unless defined $qsargs{'-e'};
# Set stdout log file for the job unless we saw a '-o /path/to/stdout' option
# bd808: I think this is a bug as $qsargs{'-o'} is not used later
push @args, '-o', $out unless defined $qsargs{'-o'};
# Set the email recipient for the job
push @args, '-M', $mailto;
# Set the jobname,
# make all resource limits hard,
# and set the hard virtual memory limit
push @args, '-N', $jobname, '-hard', '-l', "h_vmem=${memory}k";

# Define stdin, stdout, and stderr to be used when we run /usr/bin/qsub
my ($qsubinput, $qsuboutput, $qsuberror);

if($continuous) {
  # Try to make a job that will automatically restart if it crashes
  # Submit the job to the 'continuous' queue (or an explictly named queue)
  push @args, '-q', (defined $qsargs{'-q'})? $qsargs{'-q'}: 'continuous';
  # Add the '-b y|n' option if we have it (not sure why we do this)
  push @args, '-b', $qsargs{'-b'} if defined $qsargs{'-b'};
  # Write a shell script to stdin that will continue to execute our program
  # until it exits with an exit status of zero.
  my $cmdline = shell_quote($prog, @ARGV);
  ($qsubinput = qq{#!/bin/sh
    until $cmdline ; do
        echo "[`date +%Y-%d-%mT%H:%M`] $prog exited with code \$?. Respawning..." >&2
        sleep 5
    done
  }) =~ s/^ {4}//gm; # strip the leading whitespace from our script
} else {
  # Set stdin to an empty string
  $qsubinput = '';
  # Change queue name if explictly provided (will be 'task' otherwise)
  $queue = $qsargs{'-q'} if defined $qsargs{'-q'};
  # Add queue name argument,
  # set the binary submission flag,
  # and add the program and its arguments
  push @args, '-q', $queue, '-b', 'y', $prog, @ARGV;
}

# Execute $JOBUTILS_QSUB or /usr/bin/qsub using the arguments we just built
my $h = harness([exists ($ENV {'JOBUTILS_QSUB'}) ? $ENV {'JOBUTILS_QSUB'} : '/usr/bin/qsub', @args], \$qsubinput, \$qsuboutput, \$qsuberror);
if (!run ($h)) {
    # Print stdout and stderr
    print STDOUT $qsuboutput;
    print STDERR $qsuberror;
    # Exit with the same exit code as /usr/bin/qsub
    exit ($h->result ());
}

# Suppress output if the user requested so.
if (!$quiet) {
    print STDOUT $qsuboutput;
    print STDERR $qsuberror;
}
