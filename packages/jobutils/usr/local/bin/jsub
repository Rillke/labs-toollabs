#!/usr/bin/perl -w

use strict;
use warnings;

use IPC::Run qw(harness run);
use String::ShellQuote;

my %qsubargs = (
       '-a' => 1, '-b' => 1, '-cwd' => 0, '-e' => 1, '-hard' => 0, '-i' => 1, '-j' => 1,
       '-l' => 1, '-now' => 1, '-N' => 1, '-o' => 1, '-p' => 1, '-q' => 1, '-soft' => 0,
       '-sync' => 1, '-v' => 1, '-wd' => 1,
       '-mem' => 1, '-once' => 0, '-stderr' => 0, '-continuous' => 0, '-quiet' => 0,
);
my %qsargs;
my @args;
my $memory = '256m';
my $once = 0;
my $stderr = 0;
my $continuous = 0;
my $quiet = 0;
my $script = $0;
my $queue = 'task';
$script = $1 if $script =~ m{/([^/]+)$};

$continuous = $once = 1 if ($script eq 'jstart');

my @options;
while($#ARGV > 0) {
  last unless defined $qsubargs{$ARGV[0]};
  my $opt = shift;
  my $optarg = undef;
  if($qsubargs{$opt}) {
    die "$script: option $opt requires an argument\n" unless $#ARGV > 0;
    $optarg = shift;
  }
  push @options, [ $opt, $optarg ];
}


if($#ARGV<0 or $ARGV[0] =~ m/^-/) {
  print STDERR <<"END"

usage: $script [options...] program [arg...]

Options include many (but not all) qsub options, along with:
 -stderr           Send errors to stderr rather than the error
                   output file.
 -mem <value>      Request <value> amount of memory for the job.
                   (number prefixed by 'k', 'm' or 'g')
 -once             Only start one job with that name, fail if
                   another is already started or queued (default
                   if invoked as 'jstart').
 -continuous       Start a self-restarting job on the continuous
                   queue (default if invoked as 'jstart')
 -quiet            If successful, don't output anything

Unlike qsub, if you do not specify output and error files, output is appended
by default to files named <job>.err and <job>.out in your home directory
(without job numbers), including errors from starting the job itself.

Additionally, you need to provide an executable on the command line,
$script will not read a script from standard input.

END
  ;
  exit 1;
}

my $exe = shift;
my $prog = `/usr/bin/which $exe`;
chomp $prog;
while(-l $prog) {
  my $symlink = readlink $prog;
  if($symlink =~ m{^/}) {
    $prog = $symlink;
    next;
  }
  $prog =~ s{/[^/]+$}{};
  while($symlink =~ m{^\.\./(.*)}) {
    $symlink = $1;
    $prog =~ s{/[^/]+$}{};
  }
  $prog .= "/$symlink";
}

print "prog?: $prog\n";
unless($prog =~ m{^/}) {
  my $cwd = `pwd`;
  chomp $cwd;
  $prog = "$cwd/$exe";
  $prog =~ s{/\./}{/}g;
}

open EXE, "<$prog" or die "$prog: $!\n";
my $shebang;
while(read EXE, $shebang, 2) {
  last unless $shebang =~ m/^#[!\$]/;
  my $rest =<EXE>;
  next if $shebang eq '#!';
  next unless $rest =~ m/\s* ( -\S+ ) (?: \s+ ( [^# \n\t]+ ) )?/x;
  unshift @options, [ $1, $2 ];
}
close EXE;


foreach my $option (@options) {
  my($opt, $optval) = @$option;
  if($opt eq '-mem') {
    $memory = $optval;
    die "$script: memory value must be an integer followed by 'k', 'm' or 'g'\n" unless $memory =~ m/^([1-9][0-9]*[mMgGkK])$/;
  } elsif($opt eq '-once') {
    $once = 1;
  } elsif($opt eq '-stderr') {
    $stderr = 1;
  } elsif($opt eq '-continuous') {
    $continuous = 1;
    $once = 1;
  } elsif($opt eq '-quiet') {
    $quiet = 1;
  } else {
    if($opt eq '-l') {
      $memory = $1  if $optval =~ s/h_vmem=([0-9]+[mMgGkK]),?//;
      next if $optval =~ m/^,?$/;
    }
    $qsargs{$opt} = $optval;
    next if $opt eq '-N' or $opt eq '-q' or $opt eq '-b';
    push @args, $opt;
    push @args, $optval if defined $optval;
  }
}

my $jobname = 'unknown';
$jobname = $1 if $prog =~ m{([^/.]+)(\.[^/]*)?$};
$jobname = $qsargs{'-N'} if defined $qsargs{'-N'};

my $err = (getpwuid ($<)) [7] . '/' . $jobname . '.err';
my $out = (getpwuid ($<)) [7] . '/' . $jobname . '.out';

$err = $qsargs{'-e'} if defined $qsargs{'-e'};
$out = $qsargs{'-o'} if defined $qsargs{'-o'};
$err = $out if defined $qsargs{'-j'} and $qsargs{'-j'} =~ m/^[yY]/;

open STDERR, ">>$err" unless $stderr;

my $now = localtime;

die "\[$now\] $prog: not an executable file\n" unless -f $prog and -x $prog;

if($once) {
  my $running = system "/usr/local/bin/job", '-q', $jobname;
  die "\[$now\] unable to get job status\n" if $running & 127;
  $running >>= 8;
  die "\[$now\] there is a job named '$jobname' already active\n" unless $running==0;
}

push @args, '-e', $err unless defined $qsargs{'-e'};
push @args, '-o', $out unless defined $qsargs{'-o'};
push @args, '-N', $jobname, '-hard', '-l', "h_vmem=$memory";

my ($qsubinput, $qsuboutput, $qsuberror);

if($continuous) {
  push @args, '-q', 'continuous';
  push @args, '-b', $sqargs{'-b'} if defined $qsargs{'-b'};
  $qsubinput = "#!/bin/bash\n"                                   .
               "while ! " . shell_quote($prog, @ARGV) . "; do\n" .
               "  sleep 5\n"                                     .
               "done\n";
} else {
  $qsubinput = '';
  $queue = $qsargs{'-q'} if defined $qsargs{'-q'};
  push @args, '-q', $queue, '-b', 'y', $prog, @ARGV;
}

my $h = harness(['/usr/bin/qsub', @args], \$qsubinput, \$qsuboutput, \$qsuberror);
if (!run ($h)) {
    print STDOUT $qsuboutput;
    print STDERR $qsuberror;
    exit ($h->result ());
}

# Suppress output if the user requested so.
if (!$quiet) {
    print STDOUT $qsuboutput;
    print STDERR $qsuberror;
}
